---
title: 消息队列框架基础概念
tags: 消息队列,MQ,逍遥神风
grammar_cjkRuby: true
---
目录：

[TOC]

---
## MQ 介绍

对于MQ，我们需要知道4个名词：==队列管理器==、==队列==、==消息==、==通道==；对于编程设计人员,通常更关心消息和队列,对于维护管理人员,通常 会更关心队列管理器和通道。
如果我们把队列管理器比作是数据库,那么队列就是其中的一张表,消息就是表中的一条记录。

- 队列管理器：队列管理器构建了独立的MQ的运行环境，它是消息队列的管理者，用来维护和管理消息队列。
- 队列：我们可以简单地把队列看成一个容器，用于存放消息。
- 消息：MQ中的最小对象；默认情况下，消息缺省可以达到4MB。消息可以分成持久消息和非持久消息。所谓“持久”的意思,就是在MQ队列管理器重启动后,消息是否仍然能保持。持久的消息写入或读出队列的同时会在 Log 中记录,所以性能上比非持久消息差不少。
- 通道：通道则是两个队列管理器之间的一种单向的点对点的通信连接， 消息在通道中只能单向流动。队列管理器之间的通信是通过配置通道来实现 的,通道两侧的队列管理器对这个通道的相关参数应该能对应起来。在通道上可以配置不同的通信协议,这样就使得编程接口与通信协议无关。通道两端的 配置必须匹配,且名字相同,否则无法连通。

## MQ与WebService比较

Message Queue属于比较重量级的应用，在规范化的企业流程中用的比较多。如果企业有很多部门，部门都有自己的系统，那么不同的系统之间的集成通信,Message Queue是很好的选择。MQ一般都做为企业级IT应用的中间件存在，有很多企业是作为标准IT基础结构存在的。

>  易用性

- 使用Message Queue，只要把这个中间件的服务器搭建起来，只要在需要的时候加入不同的Queue Manager就可以了，然后就可以访问了，就可以作为不同系统之间的桥梁了。
- 使用WebService，需要编写很多的WebService的代码，去建立这些WebServcie，然后暴露出这些接口，相互之间调用，很费事。

> 传输方式

**MQ的使用主要是以异步处理方式**。
- 长耗时的报表，这个在程序中经常遇见，处理海量数据时，可能生成一个报表需要5分中或是更长的时间，客户不能在线实时等待，报表处理比较耗费资源，不能同时处理很多请求，甚至同时只允许处理一个，这时就可以使用MQ。客户端将报表请求和一些必要的报表条件放到Queue中，报表由另一个服务一个一个的处理，处理好后再给用户发一个消息（MSN消息，或mail等）用户再在浏览器或其他报表浏览器中查看报表。
- 在线商店，在客户下订单的过程后，系统只需做减库存、记录收货人信息和必要的日志，其他的必须配送处理、交易统计等其他处理可以不同时完成，这时就可以将后续处理消息放入Queue中，让另一台（组）服务器去处理，这样可以加快下订单的过程，提高客户的体验;

**WebService的使用主要是以同步处理方式**。通常是实时性要求较高，Client端向Server端发出请求后，这是一个短连接，一个Http请求，这个请求发出后，Client端就会一直等到获取到这个结果。但是使用MQ的话，因为有了中间的这一块区域，当请求发出后，Client端可以继续去干别的事情。等到一段时间以后再去中间件的存储区域上查看一下有结果了么，有了结果就取出来，没有的话就再等会再看。

另外，MessageQueue在于容错处理保持数据一致性上有很大的优势。参照MQ事物处理特性

## WebSphere MQ 介绍

### 事物处理特性

1. **概述**

WebSphere MQ不仅能够作为资源管理者管理自身的资源，同时能够作为资源协调者，同其他资源管理者如数据库等协同工作，即在一个全局工作单元中，保持MQ自身资源和数据库资源的数据一致性。它的事物处理功能分为两类：
- 本地工作单元`Local unit of work`，它是指参与事务处理的参与者只有MQ本身，例如，我们可以将两个put操作和一个get操作作为一个事物，通过本地工作单元支持，做到这三个动作要么全部成功要么全部回滚。
这时，要用到MQCMIT和MQBACK这两个MQ的API函数，其程序流程为：

```bash?linenums
MQCONN()   /*连接队列管理器*/
MQOPEN()   /*打开应用程序队列*/
MQGET(MQGMO_SYNCPOINT) /*队列写操作，此时，要通过设置MQGMO_SYNCPOINT 将该操作打上同步点标志，使其作为本地工作单元中的一个操作*/
MQPUT(MQPMO_SYNCPOINT) /*队列读操作，同理，设置MQPMO_SYNCPOINT*/
MQCMIT()    /*提交上述读写操作*/
MQCLOSE()    /*关闭应用程序队列*/
MQDISC()    /*断开与队列管理器的连接*/
```

- 全局工作单元`Global unit of work`，它是指参与事务处理的参与者除了MQ之外，还有其他的资源管理者，如关系型数据库等，例如，我们可以将一个队列的get操作和数据库的写操作作为一个事物，通过本地工作单元支持，做到这两个动作要么全部成功要么全部回滚。
全局工作单元又分为两种情况：
==队列管理器协调==：在这种情况下，MQ本身可以作为资源协调者(XA-Coordinator)，此时，它具备交易中间件的类似功能；
==外部事物协调==：它是指MQ产品支持采用外部交易管理器，如IBM CICS来作为XA协调者。
在采用这一功能时，除了要用到MQCMIT和MQBACK这两个MQ的API函数之外，还需要用到另外一个函数MQBEGIN，其程序流程为：

```bash?linenums
MQCONN()   /*连接队列管理器*/
MQOPEN()   /*打开应用程序队列*/
MQBEGIN()   /*标志一个全局逻辑工作单元的开始*/
MQGET(MQGMO_SYNCPOINT) /*队列写操作，此时，要通过设置MQGMO_SYNCPOINT 将该操作打上同步点标志，使其作为本地工作单元中的一个操作*/
EXEC SQL INSERT           /*数据库操作*/
MQCMIT()       /*提交上述读写操作*/
MQCLOSE()    /*关闭应用程序队列*/
MQDISC()    /*断开与队列管理器的连接*/
```

在MQI提供的13个接口函数中，MQBEGIN、MQCMIT和MQBACK是和交易处理有关的3个函数，其中，MQBEGIN标志着一个全局工作单元的开始，之后可以用MQGET和MQPUT函数对队列进行读写操作，并同时用SQL语句进行有关的数据库操作，然后，用MQCMIT或MQBACK结束该全局工作单元，在整个过程中，MQ作为资源协调者利用两阶段提交机制，保证MQ消息和数据库数据的同时提交和回滚。

2. **本地工作单元的使用**

使用MQ的分段(Segment)和分组(Group)功能对消息进行分段和分组处理是使用本地工作单元的一个最佳案例。
- 所谓分段是指把某个大消息从物理上分为若干个消息片段，比如在处理大文件传输时，可以采用消息分段技术。
- 所谓分组是指从应用逻辑的角度，把若干本身完整、在应用逻辑上又具有相关性的消息从逻辑上分为一组进行处理，比如旅行社可将向酒店、机票代理处和汽车租赁公司发出的三个查询请求消息逻辑上作为一组处理。

对于分段消息和分组消息我们都采用了本地工作单元的事务处理，将对应的消息统一进行提交和回滚处理。采用消息分段的方法实现大消息，包括大文件的传输时，一方面可以简化编程的工作量（因为MQ可以保证各消息段之间的顺序），另一方面又可以保证文件的完整性（所有消息段组成一个完整的事物将会被统一提交或回滚，不会发生其中一段丢失的现象）。这时MQ在用做数据大消息传输时的一大优势。

3. **全局工作单元的使用**

用户当前的应用大多都是与数据库应用有关的，而MQ支持两阶段提交，而且能够通过XA资源管理器这一功能与其他数据库协同工作，这是MQ迈向同关系型数据库技术更紧密集成的第一步，将允许MQ用户享受到更先进得功能，如高性能的大型数据对象处理能力、更好的安全性和日志管理。有了MQ，包含MQ和SQL操作的应用程序可以通过MQBEGIN命令开始作业单元，该作业单元中的所有MQ和数据库操作都可以使用MQCMIT和MQBACK命令提交或回滚。这在事务完整性比较重要的场合中可以保证重要业务数据不对丢失并且简化应用程序的开发。
例如，在使用MQ之前，用户使用系统的消息队列等手段进行数据通讯，在数据从系统消息队列中读取数据之后、向数据库进行写操作之前，系统发生宕机故障，由于没有两阶段提交机制的保障，该数据被丢失(==数据持久化体现==)。在采用MQ之后，可以避免此类情况的发生。

3.1 **典型使用举例**

除了对本地数据库操作保证数据一致性和完整性之外，还有一种典型的使用方法来实现远程数据库操作和本地数据库操作的同步，即实现数据库的复制。
例如，在某些项目需求中，利用MQ的这种交易性来保证本地和远程数据库操作以及MQ操作的交易完整性和数据一致性。位于本地的应用程序要对本地数据库和远程数据库进行操作，并且要保持两个数据库操作的一致性，即要实现对远程数据库操作和本地数据库操作的同时提交或同时回滚。本地数据库操作和MQPUT作为一个逻辑工作单元，MQ的传输是一个工作单元，远程MQGET和数据库操作又作为一个逻辑工作单元。当对本地数据库操作完成后，由MQ向远程发出消息，通知远程进行相应的数据库操作，远程应用读取该消息，进而对数据库进程更新。这里，本地数据库操作和MQPUT操作的交易一致性由MQ的两阶段提交机制保证；中间阶段，由MQ中间件本身传输的可靠性、安全性来保证；远程MQGET和数据库操作由MQ的两阶段提交机制来保证。利用MQ进行数据库复制的优势在于：
- 跨平台性，屏蔽数据库的异构性：可以实现不同操作系统、不同网络协议、异构数据库之间的复制。
- 传输可靠性和断点续传：网络故障不影响复制程序的进行，故障恢复后不需要重发数据；同时可以实现断点续传，这一点非常重要。举例说明：使用数据库本身的复制功能做数据库复制时，假设第一次要复制的数据量为2M，由于网络原因没有复制成功，进行下一次复制时，数据量可能会累计到5M，更加增大网络传输的难度。
- 时间独立性：实现实时或批量复制，不会受到远程主机或应用状态的影响。
- 使用简单、灵活：可以对数据进行加密或压缩；源表和目标表结构可以不同。
与数据库复制类似，这里再给出另外一种MQ两阶段提交机制的使用场合。比如，在电信和银行互连实现代交费业务时，对每一比业务处理，都会涉及电信和银行接口的问题。
我们采用MQ作为两者的接口方式，MQ支持CICS作为外部XA协调者(XA Coordinator)，它可以保证交易1和交易2中，对MQ和数据库操作的两阶段提交。与数据库复制不同的是，前台交易是一个同步的应用，在电信系统中，我们要设置交易的超时时间，当交易超时时，认为交易失败。如何解决MQ的异步工作模式和这一需求的矛盾呢？方法很简单，我们推荐大家使用MQ的消息生命周期机制。具体方法大致如下，我们对交易1发出的交易请求消息设置小于或等于超时时间的生命周期，这样，如果由于网络故障，消息堵在电信系统中，当网络恢复时，消息会自动超时，交易2就不会发生，我们也不需要做任何其他额外处理。如果请求消息在超时时间之内成功到达银行系统，交易2也成功完成，而由于网络故障交易2产生的应答消息堵在银行系统中，此时，我们对应答消息不设置生命周期，让它在网络恢复时到达电信系统，这时，我们对其作一次冲正处理。

3.2 **与数据库协同工作的配置步骤**

下面给出使用MQ的两阶段提交机制与数据库协同工作时的主要配置步骤。这里我们使用MQ产品本身提供的例子程序和相关脚本，以Windows2000/NT平台为例安装MQ产品之后，在"MQ安装目录\Tools\C\Samples\xatm"目录下，提供了下列样例脚本和程序：
- MQ协调单个数据库管理器的例子：

```bash?linenums
AMQSXAS0.SQC   源码（修改数据库MQBankDB中的表MQBankT）
amqsxas0.mak    make文件（2000/NT环境）
```
- MQ协调两个数据库管理器的例子：

```bash?linenums
AMQSXAF0.SQC   源码（修改数据库MQFeeDB中的表MQFeeTB）
AMQSXAB0.SQC   源码（修改数据库MQBankDB中的表MQBankTB）
Amqsxag0.c    源码（MQ协调两个数据库）
amqsxag0.mak   make文件（2000/NT环境）
```

- 用于DB2数据的Switch Load File(开关交换文件)

```bash?linenums
db2swit.c     交换文件源码
db2swit.def    定义文件
xaswit.mak    make文件（2000/NT环境）
xa.h      XA接口头文件
```

- 用于Oracle和Sybase数据库的Switch Load 
File(开关交换文件)，在此，我们将采用DB2数据库。

3.2.1 **具体配置步骤**

- 创建数据库MQBANKDB和MQFEEDB 
进入 db2 命令窗口： 
运行以下命令：

```sql?linenums
db2 CREATE DATABASE MQBANKDB
db2 CREATE DATABASE MQFEEDB
```

- 建表 
进入 db2 命令窗口： 
运行以下命令：

```sql?linenums
db2
connect to MQBankDB
CREATE TABLE MQBankT(Name VARCHAR(40) NOT NULL, Account INTEGER NOT NULL, 
Balance INTEGER NOT NULL, PRIMARY KEY (Account)) 
INSERT INTO MQBankT VALUES ('Mr Fred Bloggs',1,0)
INSERT INTO MQBankT VALUES ('Mrs S Smith',2,0)
INSERT INTO MQBankT VALUES ('Ms Mary Brown',3,0)
Connect reset
connect to MQBankDB
CREATE TABLE MQBankTB(Name VARCHAR(40) NOT NULL, Account INTEGER     
NOT NULL, Balance INTEGER NOT NULL, Transactions INTEGER NOT NULL, PRIMARY KEY (Account))
INSERT INTO MQBankTB VALUES ('Mr Fred Bloggs',1,0,0) 
INSERT INTO MQBankTB VALUES ('Mrs S Smith',2,0,0)
INSERT INTO MQBankTB VALUES ('Ms Mary Brown',3,0,0)
Connect reset
connect to MQFeeDB
CREATE TABLE MQFeeTB(Account INTEGER NOT NULL, FeeDue INTEGER NOT NULL, 
TranFee INTEGER NOT NULL, Transactions INTEGER NOT NULL, PRIMARY KEY (Account)) 
INSERT INTO MQFeeTB VALUES (1,0,50,0) 
INSERT INTO MQFeeTB VALUES (2,0,50,0) 
INSERT INTO MQFeeTB VALUES (3,0,50,0) 
Connect reset
```

- 创建 DB2 开关装入文件

```bash?linenums
nmake -f xaswit.mak db2swit.dll
copy db2swit.dll C:\user\dll
```

- 配置资源库
    - 修改队列管理器的属性 
在MQ Services窗口中，用鼠标右键点击队列管理器 TESTQM，将出现以下"属性"窗口：
    - 定义另一个XA资源管理器设置：
- 数据库特权设置

```bash?linenums
db2 connect to MQBankDB
db2 grant connect on database to user mqm
db2 connect to MQFeeDB
db2 grant connect on database to user mqm
```

- tp_mon_name 参数设置

```bash?linenums
db2 update dbm cfg using TP_MON_NAME mqmax
```

- 编译应用程序

```bash?linenums
cd C:\Workshop\MQ\Transaction\samples\amqsxas0
nmake -f amqsxas0.mak
cd C:\Workshop\MQ\Transaction\samples\amqsxag0
nmake -f amqsxag0.mak
```

- 运行应用程序

```bash?linenums
amqsxas0 TESTQ TESTQM
amqsxag0 TESTQ TESTQM
```

可以使用amqsput.exe将所需消息放入TESTQ中，其测试数据（放入的消息格式）为：

```sql?linenums
UPDATE Balance change=NUMBER WHERE Account=1
```

其中，斜体字符需要更换成所需值。Account的值可以是1，2，3。

相关Websphere MQ教程参考：[Websphere MQ][1]


## Rabbit MQ 介绍

RabbitMQ是AMQP（高级消息队列协议）的一个标准实现，关于它的快速入门，可以在这里查看：[Rabbit MQ][2]

1. **Rabbit MQ工作原理**

- **生产者客户端**：
    - 客户端连接到RabbitMQ服务器上，打开一个消息通道（channel）；
    - 客户端声明一个消息交换机（exchange），并设置相关属性。
    - 客户端声明一个消息队列（queue），并设置相关属性。
    - 客户端使用routing key在消息交换机（exchange）和消息队列（queue）中建立好绑定关系。
    - 客户端投递消息都消息交换机（exchange）上
    - 客户端关闭消息通道（channel）以及和服务器的连接。

- **服务器端**：
exchange接收到消息后，根据消息的key和以及设置的binding，进行消息路由，将消息投递到一个或多个消息队列中。关于exchange也有几个类型：
    - Direct交换机：完全根据key进行投递。例如，绑定时设置了routing key为abc，客户端提交信息提交信息时只有设置了key为abc的才会投递到队列；
    - Topic交换机：在key进行模式匹配后进行投递。例如：符号`#`匹配一个或多个字符，符号`*`匹配一串连续的字母字符，例如`abc.#`可以匹配`abc.def.ghi`，而`abc.*`只可以匹配`abc.def`。
    - Fanout交换机：它采取广播模式，消息进来时，将会被投递到与改交换机绑定的所有队列中。

2. **RabbitMQ的消息持久化**

RabbitMQ支持数据持久化，也就是把数据写在磁盘上，可以增加数据的安全性。消息队列持久化包括三个部分：
- 消息交换机（exchange）持久化，在声明时指定durable为1
- 消息队列（queue）持久化，在声明时指定durable为1
- 消息持久化，在投递时指定delivery_mode为2（1是非持久化）
如果消息交换机（exchange）和消息队列（queue）都是持久化的话，那么他们之间的绑定（Binding）也是持久化的。如果消息交换机和消息队列之间一个持久化、一个非持久化，那么就不允许绑定。



## Active MQ 介绍

## Websphere MQ 、Rabbit MQ、Active MQ 比较

## kafka 介绍

## kafka、Active MQ 比较

[1]:http://www-01.ibm.com/support/knowledgecenter/SSFKSJ_7.0.1/com.ibm.mq.amqzag.doc/fa10260_.htm
[2]:http://www.rabbitmq.com/getstarted.html

